#!/bin/bash
##############################################
# Low Level Librarues
# By Pablo Niklas - Under MIT License
##############################################

# paralelo(): Paralell process management
# By Pablo Niklas (pablo.niklas@gmail.com)
# Under MIT License
#
# Usage: paralelo [<list of processes to be launch concurrently>]
# Log into /tmp/corrida_paralela.PID($$).<day>.log
#
#
# ChangeLog
# 27/07/2006 - PSRN - Initial version.
# 28/07/2006 - PSRN - Logging.
#                     Replacement of seq x myseq. ;)
# 29/07/2006 - PSRN - Linux cores autodetection.
# 31/07/2006 - PSRN - Solaris compatibily and debugging.
# 01/08/2006 - PSRN - Cores autodetection in Solaris 2.6 y 9.
# 05/08/2006 - PSRN - $DEBUG overriding.
# 07/08/2006 - PSRN - $PARALELO is definining by his parent.
# 27/08/2006 - PSRN - General log for a better output.
#

function paralelo() {

    # PARALELO:
    # Quantity of paralell process: Depends on the OS and the Architecture
    # 1) Cant. of cpus + 1 (x86)
    # 2) Cant. of cpus * 2 (x86)
    # 3) Cant. of cpus     (SPARC)
    if [ -z "$PARALELO" ]; then
            PARALELO=$((`cat /proc/cpuinfo |grep ^proces|wc -l`*2)) # Linux
    fi

    # DIRLOG:
    # Directory where the temporary logs are stored.
    DIRLOG=/tmp

    ############################ BEGIN ################################

    echo ":::: START EXECUTION (`date +'%d/%m/%Y - %H:%M:%S'`)"
    echo ":::: $# process will be executed ($PARALELO concurrently)."

    # Init of system variables.
    I=0 ; SEQ=""
    while [ $I -le $(($PARALELO-1)) ] ; do
        PID[$I]=0
        SEQ=$SEQ+"$I " # In some OS seq is not available...
        I=$(($I+1))
    done

    SEQ=`echo $SEQ|sed 's/+//g'` # Taking out the "+"

    TERMINO=false
    JOBLOGTMP="job.$$.`date +'%d'`"
    TAREA=0
    while [ $# != 0 ] || ! $TERMINO; do
        A=0
        for A in $SEQ; do

            # Asigning processes if they are cores available.
            if [ ${PID[$A]} -eq 0 ] && [ $# != 0 ]; then
                TAREA=$(($TAREA+1))
                echo "::: Job #$TAREA - Thread #$A - `date +'%d/%m/%Y - %H:%M:%S'` - STARTED." >> $DIRLOG/$JOBLOGTMP.`printf %.3d $TAREA`.log
                $1 1>> $DIRLOG/$JOBLOGTMP.`printf %.3d $TAREA`.log 2>&1 &
                PID[$A]=$!
                TID[$!]=$TAREA

                echo "::: Job #$TAREA - Thread #$A - `date +'%d/%m/%Y - %H:%M:%S'` - STARTED."

                shift
            fi

            A=$(($A+1))
        done

        # Ending control loop of each thread.
        TERMINO=true
        A=0
        for A in $SEQ; do

            # Each *nix manage process in a different way. :)
            FINALIZO=false
            if [ "`uname -s`" = "SunOS" ] && [ ${PID[$A]} -gt 0 ]; then
                [ -z "`ps -p ${PID[$A]}|grep -v "   PID TTY      TIME CMD"`" ] && FINALIZO=true
            fi

            if [ "`uname -s`" = "Linux" ] && [ ${PID[$A]} -gt 0 ]; then
                [ -z "`ps --no-heading --pid ${PID[$A]}`" ] && FINALIZO=true
            fi

            if $FINALIZO ; then
                echo "::: Job #${TID[${PID[$A]}]} - Thread #$A - `date +'%d/%m/%Y - %H:%M:%S'` - ENDED." >> $DIRLOG/$JOBLOGTMP.`printf %.3d ${TID[${PID[$A]}]}`.log
                echo >> $DIRLOG/$JOBLOGTMP.`printf %.3d ${TID[${PID[$A]}]}`.log
                echo "::: Job #${TID[${PID[$A]}]} - Thread #$A - `date +'%d/%m/%Y - %H:%M:%S'` - ENDED."
                echo >> $DIRLOG/$JOBLOGTMP.`printf %.3d ${TID[${PID[$A]}]}`.log
                PID[$A]=0
            fi

            # Exit the main loop if all the thread has ended.
            if [ ${PID[$A]} -gt 0 ]; then
                TERMINO=false
                A=$(($PARALELO-1))
            fi

            A=$(($A+1))

        done
    done

    echo ":::: END EXECUTION (`date +'%d/%m/%Y - %H:%M:%S'`)"

    ############################### FIN ALGORTIMO ################################

    # Merging all the logs files in one, for all the executions.
    cat $DIRLOG/$JOBLOGTMP* >> $DIRLOG/corrida_paralela.$$.`date +'%d'`.log
    rm -f $DIRLOG/$JOBLOGTMP*

}
